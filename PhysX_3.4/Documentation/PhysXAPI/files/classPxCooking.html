<html>
	<head>
		<title>NVIDIA(R) PhysX(R) SDK 3.4 API Reference: PxCooking Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxCooking Class Reference<br>
<small>
[<a class="el" href="group__cooking.html">Cooking</a>]</small>
</h1><!-- doxytag: class="PxCooking" --><code>#include &lt;<a class="el" href="PxCooking_8h-source.html">PxCooking.h</a>&gt;</code>
<p>

<p>
<a href="classPxCooking-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#cf1f0cfa4c76ccbe42e84af17a90fb3e">release</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes this instance of the interface.  <a href="#cf1f0cfa4c76ccbe42e84af17a90fb3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#febe112057bd03660dd78dee384d5321">setParams</a> (const <a class="el" href="structPxCookingParams.html">PxCookingParams</a> &amp;params)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets cooking parameters.  <a href="#febe112057bd03660dd78dee384d5321"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="structPxCookingParams.html">PxCookingParams</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#2b65125364e71ef09bf8fd98daeb34ee">getParams</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets cooking parameters.  <a href="#2b65125364e71ef09bf8fd98daeb34ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#9da6aad06ad372657490e798722c68f8">platformMismatch</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks endianness is the same between cooking &amp; target platforms.  <a href="#9da6aad06ad372657490e798722c68f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#bfed14c83906e67228c82f14090cf8b5">cookTriangleMesh</a> (const <a class="el" href="classPxTriangleMeshDesc.html">PxTriangleMeshDesc</a> &amp;desc, <a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;stream, <a class="el" href="structPxTriangleMeshCookingResult.html#be8e2312c47cc522a546c34ea337fb64">PxTriangleMeshCookingResult::Enum</a> *condition=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cooks a triangle mesh. The results are written to the stream.  <a href="#bfed14c83906e67228c82f14090cf8b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxTriangleMesh.html">PxTriangleMesh</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#257827f6057895a7bed2e7f05c662919">createTriangleMesh</a> (const <a class="el" href="classPxTriangleMeshDesc.html">PxTriangleMeshDesc</a> &amp;desc, <a class="el" href="classPxPhysicsInsertionCallback.html">PxPhysicsInsertionCallback</a> &amp;insertionCallback)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cooks and creates a triangle mesh and inserts it into <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>.  <a href="#257827f6057895a7bed2e7f05c662919"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#70c3d33e9e89919f6659da1b528acbf6">validateTriangleMesh</a> (const <a class="el" href="classPxTriangleMeshDesc.html">PxTriangleMeshDesc</a> &amp;desc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Verifies if the triangle mesh is valid. Prints an error message for each inconsistency found.  <a href="#70c3d33e9e89919f6659da1b528acbf6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#7c9d154cb2293b3109ad9dbc5b86dc51">cookConvexMesh</a> (const <a class="el" href="classPxConvexMeshDesc.html">PxConvexMeshDesc</a> &amp;desc, <a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;stream, <a class="el" href="structPxConvexMeshCookingResult.html#c1c7b1cbfc80b0af00bec95faf1ebf42">PxConvexMeshCookingResult::Enum</a> *condition=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cooks a convex mesh. The results are written to the stream.  <a href="#7c9d154cb2293b3109ad9dbc5b86dc51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxConvexMesh.html">PxConvexMesh</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#87797d1f55b7e2ac7e68b9be59039fee">createConvexMesh</a> (const <a class="el" href="classPxConvexMeshDesc.html">PxConvexMeshDesc</a> &amp;desc, <a class="el" href="classPxPhysicsInsertionCallback.html">PxPhysicsInsertionCallback</a> &amp;insertionCallback)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cooks and creates a convex mesh and inserts it into <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>.  <a href="#87797d1f55b7e2ac7e68b9be59039fee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#b77e8c999ebbb766fb14c31e18dafaf9">validateConvexMesh</a> (const <a class="el" href="classPxConvexMeshDesc.html">PxConvexMeshDesc</a> &amp;desc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Verifies if the convex mesh is valid. Prints an error message for each inconsistency found.  <a href="#b77e8c999ebbb766fb14c31e18dafaf9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#cd3843988c38adae7b0227f6eaa079dc">computeHullPolygons</a> (const <a class="el" href="classPxSimpleTriangleMesh.html">PxSimpleTriangleMesh</a> &amp;mesh, <a class="el" href="classPxAllocatorCallback.html">PxAllocatorCallback</a> &amp;inCallback, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;nbVerts, <a class="el" href="classPxVec3.html">PxVec3</a> *&amp;vertices, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;nbIndices, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> *&amp;indices, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;nbPolygons, <a class="el" href="structPxHullPolygon.html">PxHullPolygon</a> *&amp;hullPolygons)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computed hull polygons from given vertices and triangles. Polygons are needed for <a class="el" href="classPxConvexMeshDesc.html" title="Descriptor class for PxConvexMesh.">PxConvexMeshDesc</a> rather than triangles.  <a href="#cd3843988c38adae7b0227f6eaa079dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#4f1fe97c6d0437b9b57b6853bd3a216a">cookHeightField</a> (const <a class="el" href="classPxHeightFieldDesc.html">PxHeightFieldDesc</a> &amp;desc, <a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;stream)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cooks a heightfield. The results are written to the stream.  <a href="#4f1fe97c6d0437b9b57b6853bd3a216a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxHeightField.html">PxHeightField</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#1cb07ad25394fcb3ecb52eff93990e8f">createHeightField</a> (const <a class="el" href="classPxHeightFieldDesc.html">PxHeightFieldDesc</a> &amp;desc, <a class="el" href="classPxPhysicsInsertionCallback.html">PxPhysicsInsertionCallback</a> &amp;insertionCallback)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cooks and creates a heightfield mesh and inserts it into <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>.  <a href="#1cb07ad25394fcb3ecb52eff93990e8f"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#22a1e6a4a68af0bb0f6568bb59108938">~PxCooking</a> ()</td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="22a1e6a4a68af0bb0f6568bb59108938"></a><!-- doxytag: member="PxCooking::~PxCooking" ref="22a1e6a4a68af0bb0f6568bb59108938" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxCooking::~PxCooking           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="cd3843988c38adae7b0227f6eaa079dc"></a><!-- doxytag: member="PxCooking::computeHullPolygons" ref="cd3843988c38adae7b0227f6eaa079dc" args="(const PxSimpleTriangleMesh &amp;mesh, PxAllocatorCallback &amp;inCallback, PxU32 &amp;nbVerts, PxVec3 *&amp;vertices, PxU32 &amp;nbIndices, PxU32 *&amp;indices, PxU32 &amp;nbPolygons, PxHullPolygon *&amp;hullPolygons)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::computeHullPolygons           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxSimpleTriangleMesh.html">PxSimpleTriangleMesh</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxAllocatorCallback.html">PxAllocatorCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>nbVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxVec3.html">PxVec3</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>nbIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>nbPolygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxHullPolygon.html">PxHullPolygon</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>hullPolygons</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computed hull polygons from given vertices and triangles. Polygons are needed for <a class="el" href="classPxConvexMeshDesc.html" title="Descriptor class for PxConvexMesh.">PxConvexMeshDesc</a> rather than triangles. 
<p>
Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. The output vertices, indices and polygons must be used to construct a hull.<p>
The provided <a class="el" href="classPxAllocatorCallback.html" title="Abstract base class for an application defined memory allocator that can be used...">PxAllocatorCallback</a> does allocate the out array's. It is the user responsibility to deallocated those array's.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mesh</em>&nbsp;</td><td>Simple triangle mesh containing vertices and triangles used to compute polygons. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inCallback</em>&nbsp;</td><td>Memory allocator for out array allocations. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nbVerts</em>&nbsp;</td><td>Number of vertices used by polygons. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>vertices</em>&nbsp;</td><td>Vertices array used by polygons. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nbIndices</em>&nbsp;</td><td>Number of indices used by polygons. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>indices</em>&nbsp;</td><td>Indices array used by polygons. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nbPolygons</em>&nbsp;</td><td>Number of created polygons. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hullPolygons</em>&nbsp;</td><td>Polygons array. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCooking.html#7c9d154cb2293b3109ad9dbc5b86dc51" title="Cooks a convex mesh. The results are written to the stream.">cookConvexMesh()</a> <a class="el" href="group__cooking.html#g36d3375ae49e62c3842c3fbe0c620651" title="collection of set bits defined in PxConvexFlag.">PxConvexFlags</a> <a class="el" href="classPxConvexMeshDesc.html" title="Descriptor class for PxConvexMesh.">PxConvexMeshDesc</a> <a class="el" href="classPxSimpleTriangleMesh.html" title="A structure describing a triangle mesh.">PxSimpleTriangleMesh</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7c9d154cb2293b3109ad9dbc5b86dc51"></a><!-- doxytag: member="PxCooking::cookConvexMesh" ref="7c9d154cb2293b3109ad9dbc5b86dc51" args="(const PxConvexMeshDesc &amp;desc, PxOutputStream &amp;stream, PxConvexMeshCookingResult::Enum *condition=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::cookConvexMesh           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxConvexMeshDesc.html">PxConvexMeshDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxConvexMeshCookingResult.html#c1c7b1cbfc80b0af00bec95faf1ebf42">PxConvexMeshCookingResult::Enum</a> *&nbsp;</td>
          <td class="paramname"> <em>condition</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cooks a convex mesh. The results are written to the stream. 
<p>
To create a triangle mesh object it is necessary to first 'cook' the mesh data into a form which allows the SDK to perform efficient collision detection.<p>
<a class="el" href="classPxCooking.html#7c9d154cb2293b3109ad9dbc5b86dc51" title="Cooks a convex mesh. The results are written to the stream.">cookConvexMesh()</a> allows a mesh description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.<p>
Example<p>
<div class="fragment"><pre class="fragment"><span class="comment">//TODO: Add Code Snippet Here</span>
</pre></div><p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The number of vertices and the number of convex polygons in a cooked convex mesh is limited to 255. <p>
If those limits are exceeded in either the user-provided data or the final cooked mesh, an error is reported.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The convex mesh descriptor to read the mesh from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>User stream to output the cooked data. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>condition</em>&nbsp;</td><td>Result from convex mesh cooking. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCooking.html#bfed14c83906e67228c82f14090cf8b5" title="Cooks a triangle mesh. The results are written to the stream.">cookTriangleMesh()</a> <a class="el" href="classPxCooking.html#febe112057bd03660dd78dee384d5321" title="Sets cooking parameters.">setParams()</a> <a class="el" href="structPxConvexMeshCookingResult.html#c1c7b1cbfc80b0af00bec95faf1ebf42">PxConvexMeshCookingResult::Enum</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4f1fe97c6d0437b9b57b6853bd3a216a"></a><!-- doxytag: member="PxCooking::cookHeightField" ref="4f1fe97c6d0437b9b57b6853bd3a216a" args="(const PxHeightFieldDesc &amp;desc, PxOutputStream &amp;stream)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::cookHeightField           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxHeightFieldDesc.html">PxHeightFieldDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cooks a heightfield. The results are written to the stream. 
<p>
To create a heightfield object there is an option to precompute some of calculations done while loading the heightfield data.<p>
<a class="el" href="classPxCooking.html#4f1fe97c6d0437b9b57b6853bd3a216a" title="Cooks a heightfield. The results are written to the stream.">cookHeightField()</a> allows a heightfield description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The heightfield descriptor to read the HF from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>User stream to output the cooked data. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#1806546c22306e8d44b7ff7719fbcc99" title="Creates a heightfield object from previously cooked stream.">PxPhysics.createHeightField()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bfed14c83906e67228c82f14090cf8b5"></a><!-- doxytag: member="PxCooking::cookTriangleMesh" ref="bfed14c83906e67228c82f14090cf8b5" args="(const PxTriangleMeshDesc &amp;desc, PxOutputStream &amp;stream, PxTriangleMeshCookingResult::Enum *condition=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::cookTriangleMesh           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTriangleMeshDesc.html">PxTriangleMeshDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxTriangleMeshCookingResult.html#be8e2312c47cc522a546c34ea337fb64">PxTriangleMeshCookingResult::Enum</a> *&nbsp;</td>
          <td class="paramname"> <em>condition</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cooks a triangle mesh. The results are written to the stream. 
<p>
To create a triangle mesh object it is necessary to first 'cook' the mesh data into a form which allows the SDK to perform efficient collision detection.<p>
<a class="el" href="classPxCooking.html#bfed14c83906e67228c82f14090cf8b5" title="Cooks a triangle mesh. The results are written to the stream.">cookTriangleMesh()</a> allows a mesh description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.<p>
Example<p>
<div class="fragment"><pre class="fragment"><span class="comment">//TODO: Add Code Snippet Here</span>
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The triangle mesh descriptor to read the mesh from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>User stream to output the cooked data. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>condition</em>&nbsp;</td><td>Result from triangle mesh cooking. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCooking.html#7c9d154cb2293b3109ad9dbc5b86dc51" title="Cooks a convex mesh. The results are written to the stream.">cookConvexMesh()</a> <a class="el" href="classPxCooking.html#febe112057bd03660dd78dee384d5321" title="Sets cooking parameters.">setParams()</a> <a class="el" href="classPxPhysics.html#29dcbbe128cef11eaf4ce5696c216dfd" title="Creates a triangle mesh object.">PxPhysics.createTriangleMesh()</a> <a class="el" href="structPxTriangleMeshCookingResult.html#be8e2312c47cc522a546c34ea337fb64">PxTriangleMeshCookingResult::Enum</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="87797d1f55b7e2ac7e68b9be59039fee"></a><!-- doxytag: member="PxCooking::createConvexMesh" ref="87797d1f55b7e2ac7e68b9be59039fee" args="(const PxConvexMeshDesc &amp;desc, PxPhysicsInsertionCallback &amp;insertionCallback)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxConvexMesh.html">PxConvexMesh</a>* PxCooking::createConvexMesh           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxConvexMeshDesc.html">PxConvexMeshDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxPhysicsInsertionCallback.html">PxPhysicsInsertionCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>insertionCallback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cooks and creates a convex mesh and inserts it into <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This method does the same as cookConvexMesh, but the produced convex mesh is not stored into a stream but is directly inserted in <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. Use this method if you are unable to cook offline.<p>
<a class="el" href="classPxPhysicsInsertionCallback.html" title="Callback interface that permits PxCooking to insert a TriangleMesh, HeightfieldMesh...">PxPhysicsInsertionCallback</a> can be obtained through <a class="el" href="classPxPhysics.html#7a4588fd79b87766cb81fae3ddd4f074" title="Gets PxPhysics object insertion interface.">PxPhysics::getPhysicsInsertionCallback()</a>.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The convex mesh descriptor to read the mesh from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>insertionCallback</em>&nbsp;</td><td>The insertion interface from <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classPxConvexMesh.html" title="A convex mesh.">PxConvexMesh</a> pointer on success</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCooking.html#7c9d154cb2293b3109ad9dbc5b86dc51" title="Cooks a convex mesh. The results are written to the stream.">cookConvexMesh()</a> <a class="el" href="classPxCooking.html#febe112057bd03660dd78dee384d5321" title="Sets cooking parameters.">setParams()</a> <a class="el" href="classPxPhysicsInsertionCallback.html" title="Callback interface that permits PxCooking to insert a TriangleMesh, HeightfieldMesh...">PxPhysicsInsertionCallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1cb07ad25394fcb3ecb52eff93990e8f"></a><!-- doxytag: member="PxCooking::createHeightField" ref="1cb07ad25394fcb3ecb52eff93990e8f" args="(const PxHeightFieldDesc &amp;desc, PxPhysicsInsertionCallback &amp;insertionCallback)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxHeightField.html">PxHeightField</a>* PxCooking::createHeightField           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxHeightFieldDesc.html">PxHeightFieldDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxPhysicsInsertionCallback.html">PxPhysicsInsertionCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>insertionCallback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cooks and creates a heightfield mesh and inserts it into <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The heightfield descriptor to read the HF from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>insertionCallback</em>&nbsp;</td><td>The insertion interface from <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classPxHeightField.html" title="A height field class.">PxHeightField</a> pointer on success</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCooking.html#7c9d154cb2293b3109ad9dbc5b86dc51" title="Cooks a convex mesh. The results are written to the stream.">cookConvexMesh()</a> <a class="el" href="classPxCooking.html#febe112057bd03660dd78dee384d5321" title="Sets cooking parameters.">setParams()</a> <a class="el" href="classPxPhysics.html#29dcbbe128cef11eaf4ce5696c216dfd" title="Creates a triangle mesh object.">PxPhysics.createTriangleMesh()</a> <a class="el" href="classPxPhysicsInsertionCallback.html" title="Callback interface that permits PxCooking to insert a TriangleMesh, HeightfieldMesh...">PxPhysicsInsertionCallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="257827f6057895a7bed2e7f05c662919"></a><!-- doxytag: member="PxCooking::createTriangleMesh" ref="257827f6057895a7bed2e7f05c662919" args="(const PxTriangleMeshDesc &amp;desc, PxPhysicsInsertionCallback &amp;insertionCallback)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxTriangleMesh.html">PxTriangleMesh</a>* PxCooking::createTriangleMesh           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTriangleMeshDesc.html">PxTriangleMeshDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxPhysicsInsertionCallback.html">PxPhysicsInsertionCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>insertionCallback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cooks and creates a triangle mesh and inserts it into <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd><a class="el" href="classPxPhysicsInsertionCallback.html" title="Callback interface that permits PxCooking to insert a TriangleMesh, HeightfieldMesh...">PxPhysicsInsertionCallback</a> can be obtained through <a class="el" href="classPxPhysics.html#7a4588fd79b87766cb81fae3ddd4f074" title="Gets PxPhysics object insertion interface.">PxPhysics::getPhysicsInsertionCallback()</a>.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The triangle mesh descriptor to read the mesh from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>insertionCallback</em>&nbsp;</td><td>The insertion interface from <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classPxTriangleMesh.html" title="A triangle mesh, also called a &#39;polygon soup&#39;.">PxTriangleMesh</a> pointer on success.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCooking.html#bfed14c83906e67228c82f14090cf8b5" title="Cooks a triangle mesh. The results are written to the stream.">cookTriangleMesh()</a> <a class="el" href="classPxCooking.html#febe112057bd03660dd78dee384d5321" title="Sets cooking parameters.">setParams()</a> <a class="el" href="classPxPhysics.html#29dcbbe128cef11eaf4ce5696c216dfd" title="Creates a triangle mesh object.">PxPhysics.createTriangleMesh()</a> <a class="el" href="classPxPhysicsInsertionCallback.html" title="Callback interface that permits PxCooking to insert a TriangleMesh, HeightfieldMesh...">PxPhysicsInsertionCallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2b65125364e71ef09bf8fd98daeb34ee"></a><!-- doxytag: member="PxCooking::getParams" ref="2b65125364e71ef09bf8fd98daeb34ee" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structPxCookingParams.html">PxCookingParams</a>&amp; PxCooking::getParams           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets cooking parameters. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Current cooking parameters.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxCookingParams.html" title="Structure describing parameters affecting mesh cooking.">PxCookingParams</a> <a class="el" href="classPxCooking.html#febe112057bd03660dd78dee384d5321" title="Sets cooking parameters.">setParams()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9da6aad06ad372657490e798722c68f8"></a><!-- doxytag: member="PxCooking::platformMismatch" ref="9da6aad06ad372657490e798722c68f8" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::platformMismatch           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks endianness is the same between cooking &amp; target platforms. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if there is and endian mismatch. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cf1f0cfa4c76ccbe42e84af17a90fb3e"></a><!-- doxytag: member="PxCooking::release" ref="cf1f0cfa4c76ccbe42e84af17a90fb3e" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxCooking::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Closes this instance of the interface. 
<p>
This function should be called to cleanly shut down the Cooking library before application exit.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function is required to be called to release foundation usage. </dd></dl>

</div>
</div><p>
<a class="anchor" name="febe112057bd03660dd78dee384d5321"></a><!-- doxytag: member="PxCooking::setParams" ref="febe112057bd03660dd78dee384d5321" args="(const PxCookingParams &amp;params)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxCooking::setParams           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPxCookingParams.html">PxCookingParams</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>params</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets cooking parameters. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>params</em>&nbsp;</td><td>Cooking parameters</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCooking.html#2b65125364e71ef09bf8fd98daeb34ee" title="Gets cooking parameters.">getParams()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b77e8c999ebbb766fb14c31e18dafaf9"></a><!-- doxytag: member="PxCooking::validateConvexMesh" ref="b77e8c999ebbb766fb14c31e18dafaf9" args="(const PxConvexMeshDesc &amp;desc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::validateConvexMesh           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxConvexMeshDesc.html">PxConvexMeshDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Verifies if the convex mesh is valid. Prints an error message for each inconsistency found. 
<p>
The convex mesh descriptor must contain an already created convex mesh - the vertices, indices and polygons must be provided.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function should be used if <a class="el" href="structPxConvexFlag.html#4b7bd21fa96c72b320a39e880208b4b610a876ecefb45e1c7dbaec2afed5c3ad" title="Disables the convex mesh validation to speed-up hull creation. Please use separate...">PxConvexFlag::eDISABLE_MESH_VALIDATION</a> is planned to be used in release builds.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The convex mesh descriptor to read the mesh from.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if all the validity conditions hold, false otherwise.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCooking.html#7c9d154cb2293b3109ad9dbc5b86dc51" title="Cooks a convex mesh. The results are written to the stream.">cookConvexMesh()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="70c3d33e9e89919f6659da1b528acbf6"></a><!-- doxytag: member="PxCooking::validateTriangleMesh" ref="70c3d33e9e89919f6659da1b528acbf6" args="(const PxTriangleMeshDesc &amp;desc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::validateTriangleMesh           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTriangleMeshDesc.html">PxTriangleMeshDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Verifies if the triangle mesh is valid. Prints an error message for each inconsistency found. 
<p>
The following conditions are true for a valid triangle mesh: 1. There are no duplicate vertices (within specified vertexWeldTolerance. See <a class="el" href="structPxCookingParams.html#19bb7e28765df5c8ec1a86a45004c7b6" title="Mesh weld tolerance. If mesh welding is enabled, this controls the distance at which...">PxCookingParams::meshWeldTolerance</a>) 2. There are no large triangles (within specified <a class="el" href="classPxTolerancesScale.html" title="Class to define the scale at which simulation runs. Most simulation tolerances are...">PxTolerancesScale</a>.)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The triangle mesh descriptor to read the mesh from.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if all the validity conditions hold, false otherwise.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCooking.html#bfed14c83906e67228c82f14090cf8b5" title="Cooks a triangle mesh. The results are written to the stream.">cookTriangleMesh()</a> </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxCooking_8h-source.html">PxCooking.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2016 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
